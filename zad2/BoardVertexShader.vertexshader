#version 330 core

layout(location = 0) in vec2 vertexPosition_board;
layout(location = 1) in vec3 vertexColor;

uniform float xscale;
uniform float yscale;
uniform float center_x;
uniform float center_y;
uniform float animation_phase;
uniform float alpha;
uniform int animation_mode;
uniform bool reversed;

out vec4 fragmentColor;

vec3 rgb2hsv(vec3 c);
vec3 hsv2rgb(vec3 c);
vec3 lighten_color(vec3 color, float amt);

void main(){
    vec3 color = vertexColor;

    // Base position and scale
    gl_Position.x = vertexPosition_board.x * xscale;
    gl_Position.y = vertexPosition_board.y * yscale;
    if(reversed) gl_Position.x *= -1.0f;

    // Process animation
    if(animation_mode == 0){ //uncover animation
        gl_Position.y += sign(gl_Position.y) * (gl_Position.x - 0.1) * sin( animation_phase * 3.14159265358 ) * 0.25;
        gl_Position.x *= cos( animation_phase * 3.14159265358 );
    }
    if(animation_mode == 1){
        gl_Position.x += sign(gl_Position.x) * (gl_Position.y - 0.1) * sin( animation_phase * 3.14159265358 ) * 0.25;
        gl_Position.y *= cos( animation_phase * 3.14159265358 );
    }
    if(animation_mode == 2) ; //wait animation

    // Apply color and lighting effect
    if(animation_mode == 0 || animation_mode == 1){
        float lighting = -sin( animation_phase * 3.14159265358 * 2);
        if(animation_phase >= 0.25 && animation_phase <= 0.5) lighting = -1.0;
        lighting = lighting*lighting*lighting;//*sign(lighting);
        //color += vec4(0.28*lighting);
        color = lighten_color(color, 0.4*lighting);
    }


    gl_Position.z = 0.0;
    gl_Position.w = 1.0;

    // Translate to card's position on board
    gl_Position += vec4(center_x, center_y, 0.0, 0.0);

    // Leave a (global) margin above the board
    gl_Position.y *= 0.9;
    gl_Position.y -= 0.1;

    fragmentColor = vec4(color, alpha);
}

vec3 lighten_color(vec3 color, float amt){
    return hsv2rgb( clamp( rgb2hsv(color) + vec3(0.0,0.0,amt) , vec3(0.0), vec3(1.0)));
}

// I admit, I do not know how exactly the conversion between grb<->hsv works.
// I've taken these routines from the web.
vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
